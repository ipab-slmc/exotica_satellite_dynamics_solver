#!/usr/bin/env python
from __future__ import print_function, division

import pyexotica as exo
import exotica_ilqr_solver_py, exotica_ddp_solver_py, exotica_ilqg_solver_py
from pyexotica.publish_trajectory import *
import signal, sys
from time import time, sleep
import numpy as np

exo.Setup.init_ros()
sleep(0.2)


# markers
# ===================================================================
import roslib; roslib.load_manifest('visualization_marker_tutorials')
from visualization_msgs.msg import Marker
from visualization_msgs.msg import MarkerArray
import rospy
import math
from geometry_msgs.msg import Point

topic = 'visualization_marker_array'
publisher = rospy.Publisher(topic, MarkerArray, queue_size=300)

rospy.init_node('register')
rospy.sleep(0.5)


solver1 = exo.Setup.load_solver('{exotica_satellite_dynamics_solver}/resources/config.arm.xml')
solver2 = exo.Setup.load_solver('{exotica_satellite_dynamics_solver}/resources/config.arm.taskmap.xml')
problem1 = solver1.get_problem()
problem2 = solver2.get_problem()

scene1 = problem1.get_scene()
ds1 = scene1.get_dynamics_solver()

sleep(0.2)
pub = rospy.Publisher('/exotica/CollisionShapes', MarkerArray, queue_size=1)
sleep(0.5)

m = Marker()
m.header.frame_id = 'exotica/world_frame'
m.action = Marker.ADD
m.type = Marker.SPHERE
m.scale.x = m.scale.y = m.scale.z = 0.5
m.pose.position.x = 9
m.pose.position.y = 9
m.pose.position.z = 9
m.pose.orientation.w = 1.0
m.color.a = 1.0
m.color.r = 1.0
m.id = 1
ma = MarkerArray()
ma.markers = [m]
pub.publish(ma)


solution1 = solver1.solve()
solution2 = solver2.solve()


while True:
    try:
        s = time()
        for t in range(problem1.T - 1):
            update_start = time()
            u = solution1[t,:]

            problem1.update(u, t)

            problem1.get_scene().get_kinematic_tree().publish_frames()
            # if problem.tau > update_end - update_start:
                # sleep(problem.tau - (update_end - update_start))
            sleep(0.02)
        
        for t in range(problem2.T - 1):
            update_start = time()
            u = solution2[t,:]

            problem2.update(u, t)

            problem2.get_scene().get_kinematic_tree().publish_frames()
            # if problem.tau > update_end - update_start:
                # sleep(problem.tau - (update_end - update_start))
            sleep(0.02)
        sleep(1)
    except KeyboardInterrupt:
        break
    # break
