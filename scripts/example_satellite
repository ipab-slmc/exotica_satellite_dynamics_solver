#!/usr/bin/env python
from __future__ import print_function, division

import pyexotica as exo
import exotica_ilqr_solver_py, exotica_ddp_solver_py, exotica_ilqg_solver_py
from pyexotica.publish_trajectory import *
import signal, sys
from time import time, sleep
import numpy as np

exo.Setup.init_ros()
sleep(0.2)


# markers
# ===================================================================
import roslib; roslib.load_manifest('visualization_marker_tutorials')
from visualization_msgs.msg import Marker
from visualization_msgs.msg import MarkerArray
import rospy
import math
from geometry_msgs.msg import Point

topic = 'visualization_marker_array'
publisher = rospy.Publisher(topic, MarkerArray, queue_size=300)

rospy.init_node('register')
rospy.sleep(0.5)

markerArray = MarkerArray()

def create_marker(marker_id, scale, pos, orientation, color, marker_type, ns="", mesh="package://exotica_satellite_dynamics_solver/resources/robots/satellite/satellite_base.dae"):
    marker = Marker()
    marker.id = marker_id
    marker.header.frame_id = "exotica/world_frame"
    marker.type = marker_type
    marker.action = marker.ADD
    marker.scale.x = scale['x']
    marker.scale.y = scale['y']
    marker.scale.z = scale['z']
    marker.color.a = color['a']
    marker.color.r = color['r']
    marker.color.g = color['g']
    marker.color.b = color['b']
    marker.ns = ns

    marker.pose.orientation.x = orientation['x']
    marker.pose.orientation.y = orientation['y']
    marker.pose.orientation.z = orientation['z']
    marker.pose.orientation.w = orientation['w']
    marker.pose.position.x = pos['x']
    marker.pose.position.y = pos['y']
    marker.pose.position.z = pos['z']
    if marker.type == marker.MESH_RESOURCE:
        marker.mesh_resource = mesh
        marker.mesh_use_embedded_materials = True

    return marker

# ===================================================================

# solver = exo.Setup.load_solver('{exotica_satellite_dynamics_solver}/resources/config.xml')
# solver = exo.Setup.load_solver('{exotica_satellite_dynamics_solver}/resources/config.arm.xml')
# solver = exo.Setup.load_solver('{exotica_satellite_dynamics_solver}/resources/config.apollo.xml')
# solver = exo.Setup.load_solver('{exotica_satellite_dynamics_solver}/resources/config.arm.taskmap.xml')
solver = exo.Setup.load_solver('{exotica_satellite_dynamics_solver}/resources/config.collision.xml')
problem = solver.get_problem()
scene = problem.get_scene()
ds = scene.get_dynamics_solver()

solution = solver.solve()

print('Solver took', solver.get_planning_time())
print('Solver terminated with: ', problem.termination_criterion)

# Roll out to update internal problem.X
# for t in range(problem.T - 1):
#     problem.update(solution[t,:],t)

costs = problem.get_cost_evolution()
np.savez('satellite_results', times=costs[0], costs=costs[1], X=problem.X, U=problem.U, solution=solution)

import matplotlib.pyplot as plt
fig_convergence = plt.figure()
plt.plot(range(len(costs[1])), costs[1])
plt.xlabel('Iteration')
plt.ylabel('Cost')
plt.yscale('log')
plt.grid()

fig, ax = plt.subplots(5, 3)
ax = ax.flatten()

times = [0]
for i in range(problem.T - 1):
    times.append(times[i - 1] + problem.tau)
times = times[1:]

for i in range(solution.shape[1]):
    ax[i].plot(times, solution[:,i])
    ax[i].set_xlabel('time (s.)')
    ax[i].set_ylabel('u[{0}]'.format(i))
    
    # if i < 10:
        # ax[i].set_ylim(0, 440)

plt.show()

# visualization = exo.VisualizationMoveIt(problem.get_scene())
# visualization.display_trajectory(
#     problem.X[:problem.num_positions - 1, :].T
# )

# publish_trajectory(problem.X[:problem.num_positions - 1, :].T, problem.T * problem.tau, problem)
# exit(0)

signal.signal(signal.SIGINT, sig_int_handler)
marker_array_published = False

for star_id in range(1000, 1300):
    star = create_marker(
        marker_id=star_id,
        scale={'x': .1, 'y': .1, 'z': .1},
        pos={
            'x': np.random.uniform(-25, 25),
            'y': np.random.uniform(-25, 25),
            'z': np.random.uniform(-25, 25)
        },
        orientation={'x': 0, 'y': 0, 'z': 0, 'w': 1},
        color={'a': .4, 'r': 1, 'g': 1, 'b': 1},
        marker_type=Marker().SPHERE,
        ns='stars'
    )
    markerArray.markers.append(star)

traj_line = create_marker(
    marker_id=0,
    scale={'x': .15, 'y': .15, 'z': .15},
    pos={'x': 0, 'y': 0, 'z': 0},
    orientation={'x': 0, 'y': 0, 'z': 0, 'w': 1},
    color={'a': .6, 'r': 1, 'g': 1, 'b': 1},
    marker_type=Marker().LINE_STRIP,
    ns='traj_line'
)

start = problem.X[:ds.nq,0]
end = problem.X_star[:ds.nq,-1] #problem.X[:ds.nq,-1]

start_marker = create_marker(
    marker_id=1,
    scale={'x': 1, 'y': 1, 'z': 1},
    pos={'x': start[0], 'y': start[1], 'z': start[2]},
    orientation={'x': start[3], 'y': start[4], 'z': start[5], 'w': start[6]},
    color={'a': .4, 'r': 1, 'g': 1, 'b': 1},
    marker_type=Marker().MESH_RESOURCE,
    ns='start_marker'
)
end_marker = create_marker(
    marker_id=2,
    scale={'x': 1, 'y': 1, 'z': 1},
    pos={'x': end[0], 'y': end[1], 'z': end[2]},
    orientation={'x': end[3], 'y': end[4], 'z': end[5], 'w': end[6] },
    color={'a': .4, 'r': 1, 'g': 1, 'b': 1},
    marker_type=Marker().MESH_RESOURCE,
    ns='end_marker'
)

background = create_marker(
    marker_id=3,
    scale={'x': 10, 'y': 7, 'z': 10},
    pos={'x': -10, 'y': 15, 'z': 0},
    # orientation={'x': 0, 'y': 0, 'z': 0, 'w': 1},
    orientation={'x': 0.7071, 'y': -0.7071, 'z': 0, 'w': 0},
    color={'a': 1, 'r': 0, 'g': 0, 'b': 0},
    marker_type=Marker().MESH_RESOURCE,
    mesh="package://exotica_satellite_dynamics_solver/resources/robots/galaxy/background.dae",
    ns='background'
)


target_marker = Marker()
target_marker.header.frame_id = 'exotica/world_frame'
target_marker.action = Marker.ADD
target_marker.type = Marker.SPHERE
target_marker.scale.x = target_marker.scale.y = target_marker.scale.z = 0.5
target_marker.pose.position.x = 9
target_marker.pose.position.y = 9
target_marker.pose.position.z = 9
target_marker.pose.orientation.w = 1.0
target_marker.color.a = 1.0
target_marker.color.r = 1.0
target_marker.id = 1


while True:
    try:
        background.pose.position.x = -10
        background.pose.position.y = 13
        background.pose.position.z = 0

        s = time()
        for t in range(problem.T - 1):
            background.pose.position.y -= 0.01
            update_start = time()
            u = solution[t,:]

            # u = [100, 0, 0,  0, 0, 0,  0, 0, 0, 0,    10, 0, 0]
            # print(u, t)
            problem.update(u, t)

            # print(problem.X[:,t])

            if not marker_array_published:
                p = Point()
                p.x = problem.X[0,t]
                p.y = problem.X[1,t]
                p.z = problem.X[2,t]
                traj_line.points.append(p)

            publisher.publish(markerArray)

            # marker with overlay for satellite
            problem.get_scene().get_kinematic_tree().publish_frames()
            update_end = time()
            # if problem.tau > update_end - update_start:
                # sleep(problem.tau - (update_end - update_start))
            sleep(0.02)
        e = time()
        sleep(1)
        print("Time taken to roll-out:", e-s)

        if not marker_array_published:
            markerArray.markers.append(traj_line)
            markerArray.markers.append(target_marker)
            # markerArray.markers.append(start_marker)
            # markerArray.markers.append(end_marker)
            # markerArray.markers.append(background)
            marker_array_published = True

    except KeyboardInterrupt:
        break
    # break
