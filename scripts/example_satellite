#!/usr/bin/env python
from __future__ import print_function, division

import pyexotica as exo
import exotica_ilqr_solver_py, exotica_ddp_solver_py, exotica_ilqg_solver_py
from pyexotica.publish_trajectory import *
import signal, sys
from time import time, sleep
import numpy as np

exo.Setup.init_ros()
sleep(0.2)


# markers
# ===================================================================
import roslib; roslib.load_manifest('visualization_marker_tutorials')
from visualization_msgs.msg import Marker
from visualization_msgs.msg import MarkerArray
import rospy
import math
from geometry_msgs.msg import Point

topic = 'visualization_marker_array'
publisher = rospy.Publisher(topic, MarkerArray, queue_size=300)

rospy.init_node('register')
rospy.sleep(0.5)

markerArray = MarkerArray()

def create_marker(id, scale, pos, orientation, color, type, mesh="package://exotica_satellite_dynamics_solver/resources/robots/satellite/satellite_base.dae"):
    marker = Marker()
    marker.id = id
    marker.header.frame_id = "exotica/world_frame"
    marker.type = type
    marker.action = marker.ADD
    marker.scale.x = scale['x']
    marker.scale.y = scale['y']
    marker.scale.z = scale['z']
    marker.color.a = color['a']
    marker.color.r = color['r']
    marker.color.g = color['g']
    marker.color.b = color['b']

    marker.pose.orientation.x = orientation['x']
    marker.pose.orientation.y = orientation['y']
    marker.pose.orientation.z = orientation['z']
    marker.pose.orientation.w = orientation['w']
    marker.pose.position.x = pos['x']
    marker.pose.position.y = pos['y']
    marker.pose.position.z = pos['z']
    marker.mesh_resource = mesh
    marker.mesh_use_embedded_materials = True

    return marker

# ===================================================================

solver = exo.Setup.load_solver('{exotica_satellite_dynamics_solver}/resources/config.xml')
problem = solver.get_problem()
solution = solver.solve()

print('Solver terminated with: ', problem.termination_criterion)

costs = problem.get_cost_evolution()
import matplotlib.pyplot as plt
plt.figure()
plt.plot(range(len(costs[1])), costs[1])
plt.xlabel('Iteration')
plt.ylabel('Cost')
plt.yscale('log')
plt.grid()
# plt.show()


# visualization = exo.Visualization(problem.get_scene())
# visualization.display_trajectory(
    # problem.X[:problem.num_positions, :].T
# )

# publish_trajectory(problem.X[:problem.num_positions, :].T, problem.T * problem.tau, problem)
# exit(0)

signal.signal(signal.SIGINT, sig_int_handler)
marker_array_published = False

for star_id in range(1000, 1300):
    star = create_marker(
        id=star_id,
        scale={'x': .1, 'y': .1, 'z': .1},
        pos={
            'x': np.random.uniform(-25, 25),
            'y': np.random.uniform(-25, 25),
            'z': np.random.uniform(-25, 25)
        },
        orientation={'x': 0, 'y': 0, 'z': 0, 'w': 1},
        color={'a': .4, 'r': 1, 'g': 1, 'b': 1},
        type=Marker().SPHERE
    )
    markerArray.markers.append(star)

traj_line = create_marker(
    id=0,
    scale={'x': .15, 'y': .15, 'z': .15},
    pos={'x': 0, 'y': 0, 'z': 0},
    orientation={'x': 0, 'y': 0, 'z': 0, 'w': 1},
    color={'a': .6, 'r': 1, 'g': 1, 'b': 1},
    type=Marker().LINE_STRIP,
)

start = problem.X[:,0]
end = problem.X[:,problem.T - 1]


start_marker = create_marker(
    id=1,
    scale={'x': 1, 'y': 1, 'z': 1},
    pos={'x': 0, 'y': 0, 'z': 0},
    orientation={'x': start[3], 'y': start[4], 'z': start[5], 'w': start[6]},
    color={'a': .4, 'r': 1, 'g': 1, 'b': 1},
    type=Marker().MESH_RESOURCE,
)
end_marker = create_marker(
    id=2,
    scale={'x': 1, 'y': 1, 'z': 1},
    pos={'x': end[0], 'y': end[1], 'z': end[2]},
    orientation={'x': 0, 'y': -0.4871745, 'z': 0, 'w': -0.8733046 },
    color={'a': .4, 'r': 1, 'g': 1, 'b': 1},
    type=Marker().MESH_RESOURCE,
)

background = create_marker(
    id=3,
    scale={'x': 10, 'y': 7, 'z': 10},
    pos={'x': -10, 'y': 15, 'z': 0},
    orientation={'x': 0, 'y': 0, 'z': 0, 'w': 1},
    color={'a': 1, 'r': 0, 'g': 0, 'b': 0},
    type=Marker().MESH_RESOURCE,
    mesh="package://exotica_satellite_dynamics_solver/resources/robots/galaxy/background.dae"
)


while True:
    try:
        background.pose.position.x = -10
        background.pose.position.y = 13
        background.pose.position.z = 0

        s = time()
        for t in range(problem.T - 1):

            background.pose.position.y -= 0.01
            update_start = time()
            u = solution[t,:]
            problem.update(u, t)

            # print(problem.X[:,t])

            if not marker_array_published:
                p = Point()
                p.x = problem.X[0,t]
                p.y = problem.X[1,t]
                p.z = problem.X[2,t]
                traj_line.points.append(p)

            publisher.publish(markerArray)

            # marker with overlay for satellite

            problem.get_scene().get_kinematic_tree().publish_frames()
            update_end = time()
            if problem.tau > update_end - update_start:
                sleep(problem.tau - (update_end - update_start))
                # sleep(0.1)
        e = time()
        sleep(1)
        print("Time taken to roll-out:", e-s)
        
        if not marker_array_published:
            markerArray.markers.append(traj_line)
            markerArray.markers.append(start_marker)
            markerArray.markers.append(end_marker)
            markerArray.markers.append(background)
            marker_array_published = True

    except KeyboardInterrupt:
        break


