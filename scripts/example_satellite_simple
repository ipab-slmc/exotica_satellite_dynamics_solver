#!/usr/bin/env python
from __future__ import print_function, division

import pyexotica as exo
import exotica_ilqr_solver_py, exotica_ddp_solver_py, exotica_ilqg_solver_py
from pyexotica.publish_trajectory import *
import signal, sys
from time import time, sleep
import numpy as np

exo.Setup.init_ros()
sleep(0.2)


# markers
# ===================================================================
import roslib; roslib.load_manifest('visualization_marker_tutorials')
from visualization_msgs.msg import Marker
from visualization_msgs.msg import MarkerArray
import rospy
import math
from geometry_msgs.msg import Point

import copy

topic = 'visualization_marker_array'
publisher = rospy.Publisher(topic, MarkerArray, queue_size=300)

rospy.init_node('register')
rospy.sleep(0.5)

sleep(0.2)
pub = rospy.Publisher('/exotica/CollisionShapes', MarkerArray, queue_size=1)
sleep(0.5)

m = Marker()
m.header.frame_id = 'exotica/world_frame'
m.action = Marker.ADD
m.type = Marker.SPHERE
m.scale.x = m.scale.y = m.scale.z = 0.5
m.pose.position.x = 3
m.pose.position.y = 3
m.pose.position.z = 3
m.pose.orientation.w = 1.0
m.color.a = 1.0
m.color.r = 1.0
m.id = 1
ma = MarkerArray()
ma.markers = [m]
pub.publish(ma)



solver = exo.Setup.load_solver('{exotica_satellite_dynamics_solver}/resources/config.ssl1300.xml')
problem = solver.get_problem()
# problem2 = solver2.get_problem()

scene = problem.get_scene()
ds = scene.get_dynamics_solver()
solution = solver.solve()



import matplotlib.pyplot as plt
plt.plot(solution)
plt.show()

while True:
    try:

        x = problem.X[:,0]

        for t in range(300):
            if t < problem.T - 2:
                u = solution[t,:]
            else:
                u = [0] * 20
                # u = solution[problem.T - 2, :]
                # u = solver_l2.get_feedback_control(
                #     x, problem.T - 2
                # )
                # print(u)

            update_start = time()
            
            big_X = copy.deepcopy(problem.X)
            big_X[:, 1] = x
            problem.X = big_X

            problem.update(u, 1)
            x = problem.X[:,2]
            
            scene.set_model_state(ds.get_position(problem.X[:,2]))
            problem.get_scene().get_kinematic_tree().publish_frames('exotica')

            update_end = time()
            sleep(0.05)
            # if problem.tau > update_end - update_start:
            #     sleep(problem.tau - (update_end - update_start))
        
        sleep(1)
    except KeyboardInterrupt:
        break
    # break
